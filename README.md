# QA Kafka Lab — HR Profiles Trainer

Учебный стенд для проверки обмена событиями через Kafka: продюсер → топики → консьюмеры → БД

## Архитектура (коротко)

* HTTP API (Go, fasthttp) — продюсер-ручки и вспомогательные CRUD.
* Kafka — топики: `hr.personal`, `hr.positions`, `hr.history`.
* Три независимых консьюмера (по одному на топик).
* PostgreSQL — таблицы событий, DLQ, профилей, истории занятости.
* Kafka UI — наблюдение за топиками и сообщениями.

## Потоки данных

1. Клиент отправляет запрос на продюсер-ручку.
2. Продюсер публикует событие в соответствующий топик (ключ — `employee_id`).
3. Консьюмер читает событие, валидирует, записывает «сырое» событие, применяет бизнес-изменения.
4. Ошибочные события отправляются в DLQ с причиной.

## Обязательные поля сообщений

Общее для всех событий:

* `message_id` — UUID, для идемпотентности.
* `employee_id` — строка, ключ агрегации.

`hr.personal`:

* Обязательное: `first_name`, `last_name`, `birth_date`, `contacts.email`, `contacts.phone`.
* Валидация: дата в формате YYYY-MM-DD; email содержит «@».

`hr.positions`:

* Обязательное: `title`, `department`, `effective_from`.
* Необязательное с перечислимым значением: `grade ∈ {Junior, Middle, Senior, Lead, Head}`.
* Валидация: дата в формате YYYY-MM-DD; grade — строго из набора.

`hr.history`:

* Обязательное: `company`, `period.from`, `period.to`.
* Валидация: даты в формате YYYY-MM-DD; `to ≥ from`.
* Необязательное: `position`, `stack` (массив строк).

## Поведение при ошибках

* Ошибка валидации у консьюмера: событие не коммитится, записывается в DLQ с причиной и исходным payload.
* Дубликаты по `message_id`: повторная обработка не выполняется.

## Нефункциональные требования

* Безопасность: Kafka не публикуется наружу; доступ извне только к UI и HTTP API через прокси.
* Изоляция: отдельная сеть, отдельная БД, раздельные контейнеры.
* Идемпотентность: защита по `message_id` на уровне событий/бизнес-таблиц.
* Наблюдаемость: логи в stdout, читаемые, без чувствительных данных.
* Ресурсы: не более 1 ГБ RAM и 1 CPU.
* Развёртывание: одной командой; полная очистка окружения возможна внешней командой остановки с удалением томов.

## Интерфейсы (сводно)

Продюсер:

* `POST /producer/personal`
* `POST /producer/position`
* `POST /producer/history`

Профили:

* `POST /profiles`
* `PUT /profiles/{employee_id}` — частичное обновление (обновляются только переданные опциональные поля).
* `DELETE /profiles/{employee_id}`
* `GET /profiles/{employee_id}`
* `GET /profiles`

История занятости:

* `POST /history`
* `PUT /history/{id}`
* `DELETE /history/{id}`
* `GET /history/{employee_id}`

События и DLQ:

* `GET /events`
* `GET /dlq`

Health:

* `GET /health`

## QA-сценарии (чек-лист)

1. Базовый поток: персональные данные → запись в профиль и событие в журнале.
2. Порядок сообщений: серия по одному сотруднику → проверка порядка по partition/offset.
3. Идемпотентность: повтор одного `message_id` не изменяет состояние повторно.
4. Ошибки: невалидная дата/JSON → попадание в DLQ с причиной.
5. Отставание: остановить консьюмера, отправить сообщения, запустить — должна произойти дочитка и применение.

## Критерии приёмки

* Сервисы поднимаются без ошибок.
* В UI видны три топика, сообщения доходят.
* Дубликаты не порождают повторных применений.
* Ошибочные события попадают в DLQ с корректной причиной.
* Чтение событий и состояний доступно через HTTP.
* Полная очистка окружения приводит систему в исходное состояние.

## Эксплуатационные заметки

* Конфигурация задаётся переменными окружения/файлами конфигурации (порт API, строка подключения к БД, адрес Kafka, имена топиков).
* При частичном обновлении профиля обновляются только переданные опциональные поля; непереданные остаются без изменений.
* Для `employee_profile` рекомендуется хранить отметку времени последнего обновления для удобства сортировки в списках.
